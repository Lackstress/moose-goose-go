<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Enhanced UNO Multiplayer</title>
  <link rel="stylesheet" href="/styles.css">
  <style>
    .game-wrapper {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
      background: var(--bg-card);
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }

    .game-header {
      text-align: center;
      margin-bottom: 2rem;
    }

    .game-title {
      font-size: 3rem;
      font-weight: 800;
      background: linear-gradient(135deg, #ef4444, #f59e0b, #22c55e, #3b82f6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 1rem;
      animation: colorShift 3s ease infinite;
    }

    @keyframes colorShift {
      0%, 100% { filter: hue-rotate(0deg); }
      50% { filter: hue-rotate(180deg); }
    }

    .game-modes {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1.5rem;
      margin-bottom: 2rem;
    }

    .mode-card {
      background: var(--bg-card-hover);
      border: 2px solid var(--border-color);
      border-radius: 16px;
      padding: 2rem;
      text-align: center;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }

    .mode-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(239, 68, 68, 0.2), transparent);
      transition: left 0.6s;
    }

    .mode-card:hover::before {
      left: 100%;
    }

    .mode-card:hover {
      transform: translateY(-5px);
      border-color: #ef4444;
      box-shadow: 0 10px 30px rgba(239, 68, 68, 0.3);
    }

    .mode-icon {
      font-size: 3rem;
      margin-bottom: 1rem;
      display: block;
    }

    .mode-title {
      font-size: 1.5rem;
      font-weight: bold;
      color: var(--text-primary);
      margin-bottom: 0.5rem;
    }

    .mode-description {
      color: var(--text-secondary);
      margin-bottom: 1.5rem;
      font-size: 0.9rem;
    }

    .mode-btn {
      background: linear-gradient(135deg, #ef4444, #f59e0b);
      color: white;
      border: none;
      padding: 1rem 2rem;
      border-radius: 12px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      font-size: 1rem;
    }

    .mode-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 5px 20px rgba(239, 68, 68, 0.4);
    }

    .game-area {
      display: none;
    }

    .game-table {
      background: radial-gradient(ellipse at center, #1a5c1a, #0d2e0d);
      border-radius: 20px;
      padding: 2rem;
      margin-bottom: 2rem;
      box-shadow: inset 0 4px 20px rgba(0, 0, 0, 0.5);
      min-height: 400px;
      position: relative;
    }

    .opponent-area {
      display: flex;
      justify-content: center;
      margin-bottom: 2rem;
    }

    .opponent-cards {
      display: flex;
      gap: -20px;
    }

    .card-back {
      width: 60px;
      height: 90px;
      background: linear-gradient(135deg, #1e40af, #3730a3);
      border: 2px solid #fbbf24;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      font-size: 1.2rem;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }

    .play-area {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 2rem;
      margin: 2rem 0;
    }

    .discard-pile {
      position: relative;
    }

    .player-area {
      display: flex;
      justify-content: center;
      margin-top: 2rem;
    }

    .player-cards {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .uno-card {
      width: 70px;
      height: 105px;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 2rem;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      border: 3px solid white;
      position: relative;
    }

    .uno-card:hover {
      transform: translateY(-10px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
    }

    .uno-card.red { background: linear-gradient(135deg, #ef4444, #dc2626); color: white; }
    .uno-card.blue { background: linear-gradient(135deg, #3b82f6, #2563eb); color: white; }
    .uno-card.green { background: linear-gradient(135deg, #22c55e, #16a34a); color: white; }
    .uno-card.yellow { background: linear-gradient(135deg, #fbbf24, #f59e0b); color: #1f2937; }
    .uno-card.wild { 
      background: linear-gradient(135deg, #ef4444 25%, #3b82f6 25%, #3b82f6 50%, #22c55e 50%, #22c55e 75%, #fbbf24 75%);
      color: white;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
    }

    .game-info {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .info-card {
      background: var(--bg-card-hover);
      border: 2px solid var(--border-color);
      border-radius: 12px;
      padding: 1.5rem;
      text-align: center;
    }

    .info-label {
      font-size: 0.9rem;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
    }

    .info-value {
      font-size: 1.8rem;
      font-weight: bold;
      color: var(--text-primary);
    }

    .controls {
      display: flex;
      gap: 1rem;
      justify-content: center;
      flex-wrap: wrap;
    }

    .btn {
      padding: 1rem 2rem;
      border: none;
      border-radius: 12px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      font-size: 1rem;
    }

    .btn-primary {
      background: linear-gradient(135deg, #ef4444, #f59e0b);
      color: white;
    }

    .btn-secondary {
      background: var(--bg-card-hover);
      color: var(--text-primary);
      border: 2px solid var(--border-color);
    }

    .btn-uno {
      background: linear-gradient(135deg, #ef4444, #dc2626);
      color: white;
      font-size: 1.5rem;
      padding: 1rem 3rem;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
    }

    .color-picker {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--bg-card);
      border: 3px solid var(--border-color);
      border-radius: 16px;
      padding: 2rem;
      z-index: 1000;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .color-picker.show {
      display: block;
    }

    .color-options {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 1rem;
    }

    .color-option {
      width: 80px;
      height: 80px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s;
      border: 3px solid white;
    }

    .color-option:hover {
      transform: scale(1.1);
    }

    .color-option.red { background: linear-gradient(135deg, #ef4444, #dc2626); }
    .color-option.blue { background: linear-gradient(135deg, #3b82f6, #2563eb); }
    .color-option.green { background: linear-gradient(135deg, #22c55e, #16a34a); }
    .color-option.yellow { background: linear-gradient(135deg, #fbbf24, #f59e0b); }

    .current-turn {
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
      padding: 1rem;
      border-radius: 12px;
      text-align: center;
      margin-bottom: 1rem;
      font-weight: bold;
      font-size: 1.2rem;
    }

    .multiplayer-info {
      background: var(--bg-card-hover);
      border: 2px solid var(--border-color);
      border-radius: 12px;
      padding: 1rem;
      margin-bottom: 1rem;
      display: none;
    }

    .player-list {
      display: flex;
      gap: 1rem;
      justify-content: center;
      flex-wrap: wrap;
    }

    .player-tag {
      background: var(--bg-card);
      padding: 0.5rem 1rem;
      border-radius: 8px;
      font-weight: bold;
    }

    .player-tag.active {
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
    }

    @media (max-width: 768px) {
      .game-modes {
        grid-template-columns: 1fr;
      }

      .uno-card {
        width: 60px;
        height: 90px;
        font-size: 1.5rem;
      }

      .card-back {
        width: 50px;
        height: 75px;
      }
    }
  </style>
</head>
<body class="dark-theme">
  <header class="header-dark">
    <div class="header-container">
      <div class="logo"><h1>üé¥ ENHANCED UNO</h1></div>
      <div id="authSection" class="auth-buttons"></div>
    </div>
  </header>

  <main class="container-dark">
    <div class="game-wrapper">
      <div class="game-header">
        <h1 class="game-title">Enhanced UNO Multiplayer</h1>
        <p style="color: var(--text-secondary);">Classic card game with modern multiplayer features</p>
      </div>

      <!-- Game Mode Selection -->
      <div id="modeSelection" class="game-modes">
        <div class="mode-card">
          <span class="mode-icon">ü§ñ</span>
          <div class="mode-title">vs Computer</div>
          <div class="mode-description">Play against AI opponents with different difficulty levels</div>
          <button class="mode-btn" onclick="startComputerGame()">Play Now</button>
        </div>

        <div class="mode-card">
          <span class="mode-icon">üë•</span>
          <div class="mode-title">Local Multiplayer</div>
          <div class="mode-description">Play with friends on the same device</div>
          <button class="mode-btn" onclick="startLocalGame()">Play Now</button>
        </div>

        <div class="mode-card">
          <span class="mode-icon">üåê</span>
          <div class="mode-title">Online Multiplayer</div>
          <div class="mode-description">Compete with players worldwide in real-time matches</div>
          <button class="mode-btn" onclick="startOnlineGame()">Find Match</button>
        </div>

        <div class="mode-card">
          <span class="mode-icon">‚ö°</span>
          <div class="mode-title">Turbo Mode</div>
          <div class="mode-description">Fast-paced games with special power cards</div>
          <button class="mode-btn" onclick="startTurboGame()">Turbo Mode</button>
        </div>
      </div>

      <!-- Game Area -->
      <div id="gameArea" class="game-area">
        <div class="multiplayer-info" id="multiplayerInfo">
          <div class="player-list" id="playerList"></div>
        </div>

        <div class="game-info">
          <div class="info-card">
            <div class="info-label">Your Cards</div>
            <div class="info-value" id="cardCount">0</div>
          </div>
          <div class="info-card">
            <div class="info-label">Current Color</div>
            <div class="info-value" id="currentColor">-</div>
          </div>
          <div class="info-card">
            <div class="info-label">Direction</div>
            <div class="info-value" id="direction">‚Üí</div>
          </div>
          <div class="info-card">
            <div class="info-label">Turn Timer</div>
            <div class="info-value" id="turnTimer">30</div>
          </div>
        </div>

        <div class="current-turn" id="currentTurn">Your Turn</div>

        <div class="game-table">
          <div class="opponent-area">
            <div class="opponent-cards" id="opponentCards"></div>
          </div>

          <div class="play-area">
            <div class="card-back" onclick="drawCard()">
              <div>üé¥</div>
            </div>
            <div class="discard-pile" id="discardPile"></div>
          </div>

          <div class="player-area">
            <div class="player-cards" id="playerCards"></div>
          </div>
        </div>

        <div class="controls">
          <button class="btn btn-uno" onclick="callUno()" id="unoBtn">UNO!</button>
          <button class="btn btn-primary" onclick="startGame()">New Game</button>
          <button class="btn btn-secondary" onclick="backToMenu()">Menu</button>
        </div>
      </div>

      <!-- Color Picker Modal -->
      <div class="color-picker" id="colorPicker">
        <h3 style="text-align: center; margin-bottom: 1rem; color: var(--text-primary);">Choose a Color</h3>
        <div class="color-options">
          <div class="color-option red" onclick="selectColor('red')"></div>
          <div class="color-option blue" onclick="selectColor('blue')"></div>
          <div class="color-option green" onclick="selectColor('green')"></div>
          <div class="color-option yellow" onclick="selectColor('yellow')"></div>
        </div>
      </div>
    </div>
  </main>

  <div id="authModal" class="modal">
    <div class="modal-content">
      <span class="close" onclick="closeModal()">&times;</span>
      <div id="modalContent"></div>
    </div>
  </div>

  <div id="notificationContainer" class="notification-container"></div>

  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <script>
    // Fallback functions if main.js doesn't load
    let currentUser = null;
    let userCoins = 1000;
    let socket = null;
    
    // Initialize socket
    try {
      socket = io();
    } catch (error) {
      console.log('Socket.io not available, using fallback');
    }
    
    // Fallback notification system
    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 15px 20px;
        background: ${type === 'error' ? '#ef4444' : type === 'success' ? '#10b981' : type === 'warning' ? '#f59e0b' : '#3b82f6'};
        color: white;
        border-radius: 8px;
        z-index: 9999;
        font-family: Arial, sans-serif;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      `;
      notification.textContent = message;
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.remove();
      }, 3000);
    }
    
    // Fallback auth functions
    function updateAuthUI() {
      console.log('Auth UI updated');
    }
    
    function setupSocketListeners() {
      console.log('Socket listeners setup');
    }
    
    // Try to load main.js, but don't fail if it doesn't load
    const script = document.createElement('script');
    script.src = '/js/main.js';
    script.onerror = function() {
      console.log('Main.js failed to load, using fallback functions');
    };
    document.head.appendChild(script);
  </script>
  <script>
    // Game State
    let gameState = {
      deck: [],
      playerHand: [],
      opponentHand: [],
      discardPile: [],
      currentPlayer: 'player',
      currentColor: null,
      currentValue: null,
      direction: 1,
      gameMode: null,
      gameActive: false,
      mustCallUno: false,
      hasCalledUno: false,
      multiplayerRoom: null,
      turnTimer: 30,
      timerInterval: null
    };

    // Socket is already declared in main.js, just make sure it's initialized
    if (!socket) {
      socket = io();
    }

    // Card definitions
    const colors = ['red', 'blue', 'green', 'yellow'];
    const values = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'skip', 'reverse', 'draw2'];
    const wildCards = ['wild', 'wild4'];

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      updateAuthUI();
      setupSocketListeners();
    });

    function setupSocketListeners() {
      socket.on('match-found', (data) => {
        gameState.multiplayerRoom = data.room;
        gameState.gameMode = 'multiplayer';
        
        document.getElementById('modeSelection').style.display = 'none';
        document.getElementById('gameArea').style.display = 'block';
        document.getElementById('multiplayerInfo').style.display = 'flex';
        
        updatePlayerList();
        startGame();
        
        showNotification('üéÆ Match found! Good luck!', 'success');
      });

      socket.on('game-action', (data) => {
        handleMultiplayerAction(data);
      });

      socket.on('error', (data) => {
        showNotification(data.message || 'An error occurred', 'error');
      });
    }

    function updateAuthUI() {
      document.getElementById('authSection').innerHTML = currentUser
        ? `<div class="user-info"><span>üë§ ${currentUser.username}</span><span class="coins">üí∞ ${userCoins}</span></div>`
        : '<button onclick="showLoginModal()" class="btn">Login</button>';
    }

    function createDeck() {
      const deck = [];
      
      // Add colored cards
      colors.forEach(color => {
        values.forEach(value => {
          deck.push({ color, value, type: 'number' });
          if (value !== '0') {
            deck.push({ color, value, type: 'number' });
          }
        });
      });
      
      // Add wild cards
      for (let i = 0; i < 4; i++) {
        wildCards.forEach(value => {
          deck.push({ color: 'wild', value, type: 'wild' });
        });
      }
      
      return shuffleDeck(deck);
    }

    function shuffleDeck(deck) {
      const shuffled = [...deck];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }

    function startComputerGame() {
      console.log('Starting computer game...');
      try {
        gameState.gameMode = 'computer';
        document.getElementById('modeSelection').style.display = 'none';
        document.getElementById('gameArea').style.display = 'block';
        document.getElementById('multiplayerInfo').style.display = 'none';
        
        // Show immediate feedback
        showNotification('üéÆ Starting UNO vs Computer...', 'success');
        
        // Start game with error handling
        startGame();
        
      } catch (error) {
        console.error('Error in startComputerGame:', error);
        showNotification('Error starting game: ' + error.message, 'error');
      }
    }

    function startLocalGame() {
      console.log('Starting local game...');
      try {
        gameState.gameMode = 'local';
        document.getElementById('modeSelection').style.display = 'none';
        document.getElementById('gameArea').style.display = 'block';
        document.getElementById('multiplayerInfo').style.display = 'none';
        
        showNotification('üéÆ Starting Local Multiplayer...', 'success');
        startGame();
        
      } catch (error) {
        console.error('Error in startLocalGame:', error);
        showNotification('Error starting game: ' + error.message, 'error');
      }
    }

    function startOnlineGame() {
      console.log('Starting online game...');
      try {
        if (!currentUser) {
          showNotification('Please login to play online', 'error');
          return;
        }
        
        gameState.gameMode = 'online';
        document.getElementById('modeSelection').style.display = 'none';
        document.getElementById('gameArea').style.display = 'block';
        document.getElementById('multiplayerInfo').style.display = 'flex';
        
        showNotification('üåê Finding online match...', 'info');
        // In real implementation, this would connect to server
        startGame();
        
      } catch (error) {
        console.error('Error in startOnlineGame:', error);
        showNotification('Error starting game: ' + error.message, 'error');
      }
    }

    function startTurboGame() {
      console.log('Starting turbo game...');
      try {
        gameState.gameMode = 'turbo';
        document.getElementById('modeSelection').style.display = 'none';
        document.getElementById('gameArea').style.display = 'block';
        document.getElementById('multiplayerInfo').style.display = 'none';
        
        showNotification('‚ö° Starting Turbo Mode...', 'success');
        startGame();
        
      } catch (error) {
        console.error('Error in startTurboGame:', error);
        showNotification('Error starting game: ' + error.message, 'error');
      }
    }

    function startGame() {
      console.log('Starting UNO game...');
      // Reset game state
      gameState.deck = createDeck();
      gameState.playerHand = [];
      gameState.opponentHand = [];
      gameState.discardPile = [];
      gameState.currentPlayer = 'player';
      gameState.gameActive = true;
      gameState.hasCalledUno = false;
      
      console.log('Deck created with', gameState.deck.length, 'cards');
      
      // Deal initial cards
      for (let i = 0; i < 7; i++) {
        gameState.playerHand.push(gameState.deck.pop());
        gameState.opponentHand.push(gameState.deck.pop());
      }
      
      console.log('Player hand:', gameState.playerHand.length, 'cards');
      console.log('Opponent hand:', gameState.opponentHand.length, 'cards');
      
      // Start discard pile with a number card
      let firstCard;
      do {
        firstCard = gameState.deck.pop();
      } while (firstCard.type === 'wild');
      
      gameState.discardPile.push(firstCard);
      gameState.currentColor = firstCard.color;
      gameState.currentValue = firstCard.value;
      
      console.log('First card:', firstCard);
      
      updateDisplay();
      startTurnTimer();
      
      console.log('Game started successfully!');
    }

    function updateDisplay() {
      console.log('Updating display...');
      updatePlayerHand();
      updateOpponentHand();
      updateDiscardPile();
      updateGameInfo();
      updateCurrentTurn();
      console.log('Display updated successfully!');
    }

    function updatePlayerHand() {
      const container = document.getElementById('playerCards');
      container.innerHTML = gameState.playerHand.map((card, index) => `
        <div class="uno-card ${card.color}" onclick="playCard(${index})">
          ${getCardDisplay(card)}
        </div>
      `).join('');
      
      document.getElementById('cardCount').textContent = gameState.playerHand.length;
      
      // Show/hide UNO button
      document.getElementById('unoBtn').style.display = 
        gameState.playerHand.length === 2 && !gameState.hasCalledUno ? 'block' : 'none';
    }

    function updateOpponentHand() {
      const container = document.getElementById('opponentCards');
      container.innerHTML = gameState.opponentHand.map(() => `
        <div class="card-back">üé¥</div>
      `).join('');
    }

    function updateDiscardPile() {
      const container = document.getElementById('discardPile');
      if (gameState.discardPile.length > 0) {
        const topCard = gameState.discardPile[gameState.discardPile.length - 1];
        container.innerHTML = `
          <div class="uno-card ${gameState.currentColor || topCard.color}">
            ${getCardDisplay(topCard)}
          </div>
        `;
      }
    }

    function updateGameInfo() {
      const colorDisplay = {
        red: 'üî¥',
        blue: 'üîµ',
        green: 'üü¢',
        yellow: 'üü°'
      };
      
      document.getElementById('currentColor').textContent = 
        colorDisplay[gameState.currentColor] || '-';
      document.getElementById('direction').textContent = 
        gameState.direction === 1 ? '‚Üí' : '‚Üê';
    }

    function updateCurrentTurn() {
      const turnEl = document.getElementById('currentTurn');
      if (gameState.currentPlayer === 'player') {
        turnEl.textContent = 'üéØ Your Turn';
        turnEl.style.background = 'linear-gradient(135deg, #10b981, #059669)';
      } else {
        turnEl.textContent = '‚è≥ Opponent\'s Turn';
        turnEl.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
      }
    }

    function getCardDisplay(card) {
      if (card.type === 'wild') {
        return card.value === 'wild4' ? '+4' : 'üåà';
      }
      
      const displayMap = {
        'skip': '‚äò',
        'reverse': '‚Üª',
        'draw2': '+2'
      };
      
      return displayMap[card.value] || card.value;
    }

    function canPlayCard(card) {
      if (card.type === 'wild') return true;
      
      const topCard = gameState.discardPile[gameState.discardPile.length - 1];
      return card.color === gameState.currentColor || 
             card.value === gameState.currentValue;
    }

    function playCard(index) {
      if (!gameState.gameActive || gameState.currentPlayer !== 'player') return;
      
      const card = gameState.playerHand[index];
      if (!canPlayCard(card)) {
        showNotification('You cannot play that card!', 'error');
        return;
      }
      
      // Remove card from hand
      gameState.playerHand.splice(index, 1);
      gameState.discardPile.push(card);
      
      // Handle special cards
      const shouldSwitchTurn = handleSpecialCard(card);
      
      // Check for win
      if (gameState.playerHand.length === 0) {
        endGame('player');
        return;
      }
      
      // Check if UNO should have been called
      if (gameState.playerHand.length === 1 && !gameState.hasCalledUno) {
        // Penalty for not calling UNO
        drawCards('player', 2);
        showNotification('Forgot to call UNO! Draw 2 cards!', 'warning');
      }
      
      gameState.hasCalledUno = false;
      
      // Send move to server in multiplayer
      if (gameState.gameMode === 'multiplayer' && gameState.multiplayerRoom) {
        socket.emit('game-action', {
          action: 'play-card',
          card: card,
          roomId: gameState.multiplayerRoom.id
        });
      }
      
      // Switch turns if not a wild card waiting for color selection
      if (shouldSwitchTurn && card.value !== 'skip' && card.value !== 'reverse') {
        switchTurn();
      }
      
      updateDisplay();
    }

    function handleSpecialCard(card) {
      switch (card.value) {
        case 'skip':
          // Skip next player (handled in turn switching)
          break;
        case 'reverse':
          gameState.direction *= -1;
          break;
        case 'draw2':
          const nextPlayer = gameState.currentPlayer === 'player' ? 'opponent' : 'player';
          drawCards(nextPlayer, 2);
          break;
        case 'wild4':
          const targetPlayer = gameState.currentPlayer === 'player' ? 'opponent' : 'player';
          drawCards(targetPlayer, 4);
          // Fall through to wild
        case 'wild':
          if (gameState.currentPlayer === 'player') {
            showColorPicker();
            // Don't switch turn here - wait for color selection
            return false; // Indicate turn should not switch yet
          } else {
            // AI chooses most common color in hand
            chooseColorAI();
            // AI automatically switches turn after choosing color
            return true; // Indicate turn should switch
          }
          break;
      }
      
      if (card.type !== 'wild') {
        gameState.currentColor = card.color;
        gameState.currentValue = card.value;
      }
      
      return true; // Default: switch turn for non-wild cards
    }

    function showColorPicker() {
      document.getElementById('colorPicker').classList.add('show');
    }

    function selectColor(color) {
      gameState.currentColor = color;
      document.getElementById('colorPicker').classList.remove('show');
      updateDisplay();
      
      // Continue turn after color selection
      switchTurn();
    }

    function chooseColorAI() {
      const colorCount = {};
      colors.forEach(color => colorCount[color] = 0);
      
      gameState.opponentHand.forEach(card => {
        if (card.color !== 'wild') {
          colorCount[card.color]++;
        }
      });
      
      // If all cards are wild or no colors found, pick randomly
      const validColors = Object.keys(colorCount).filter(color => colorCount[color] > 0);
      if (validColors.length === 0) {
        gameState.currentColor = colors[Math.floor(Math.random() * colors.length)];
      } else {
        const maxColor = validColors.reduce((a, b) => 
          colorCount[a] > colorCount[b] ? a : b
        );
        gameState.currentColor = maxColor;
      }
    }

    function drawCard() {
      if (!gameState.gameActive) return;
      
      if (gameState.deck.length === 0) {
        reshuffleDeck();
      }
      
      const drawnCard = gameState.deck.pop();
      
      if (gameState.currentPlayer === 'player') {
        gameState.playerHand.push(drawnCard);
        showNotification(`Drew a ${getCardDisplay(drawnCard)}!`, 'info');
        
        // Check if drawn card can be played
        if (!canPlayCard(drawnCard)) {
          switchTurn();
        }
      } else {
        gameState.opponentHand.push(drawnCard);
        switchTurn();
      }
      
      updateDisplay();
    }

    function drawCards(player, count) {
      for (let i = 0; i < count; i++) {
        if (gameState.deck.length === 0) {
          reshuffleDeck();
        }
        
        const card = gameState.deck.pop();
        if (player === 'player') {
          gameState.playerHand.push(card);
        } else {
          gameState.opponentHand.push(card);
        }
      }
    }

    function reshuffleDeck() {
      if (gameState.discardPile.length > 1) {
        const topCard = gameState.discardPile.pop();
        gameState.deck = shuffleDeck(gameState.discardPile);
        gameState.discardPile = [topCard];
      }
    }

    function callUno() {
      if (gameState.playerHand.length === 2) {
        gameState.hasCalledUno = true;
        showNotification('UNO!', 'success');
        document.getElementById('unoBtn').style.display = 'none';
      }
    }

    function switchTurn() {
      gameState.currentPlayer = gameState.currentPlayer === 'player' ? 'opponent' : 'player';
      resetTurnTimer();
      updateDisplay();
      
      if (gameState.currentPlayer === 'opponent') {
        setTimeout(opponentTurn, 1500);
      }
    }

    function opponentTurn() {
      if (!gameState.gameActive || gameState.currentPlayer !== 'opponent') return;
      
      console.log('AI turn starting...');
      
      // Find playable cards
      const playableCards = gameState.opponentHand.filter(canPlayCard);
      
      if (playableCards.length > 0) {
        // Smart AI strategy: prioritize special cards
        let cardToPlay;
        
        // Try to play special cards first
        const specialCards = playableCards.filter(card => 
          card.value === 'wild4' || card.value === 'wild' || card.value === 'draw2'
        );
        
        if (specialCards.length > 0 && Math.random() > 0.3) {
          // Play a special card
          cardToPlay = specialCards[Math.floor(Math.random() * specialCards.length)];
        } else {
          // Play a random playable card
          cardToPlay = playableCards[Math.floor(Math.random() * playableCards.length)];
        }
        
        const cardIndex = gameState.opponentHand.indexOf(cardToPlay);
        
        console.log('AI playing:', cardToPlay);
        
        gameState.opponentHand.splice(cardIndex, 1);
        gameState.discardPile.push(cardToPlay);
        
        const shouldSwitchTurn = handleSpecialCard(cardToPlay);
        
        // Check for win
        if (gameState.opponentHand.length === 0) {
          endGame('opponent');
          return;
        }
        
        // AI calls UNO
        if (gameState.opponentHand.length === 1) {
          showNotification('Opponent calls UNO!', 'info');
        }
        
        // Switch turns if appropriate
        if (shouldSwitchTurn && cardToPlay.value !== 'skip' && cardToPlay.value !== 'reverse') {
          switchTurn();
        }
      } else {
        // Draw a card
        console.log('AI drawing a card...');
        drawCard();
        switchTurn();
      }
      
      updateDisplay();
    }

    function startTurnTimer() {
      resetTurnTimer();
      gameState.timerInterval = setInterval(() => {
        gameState.turnTimer--;
        document.getElementById('turnTimer').textContent = gameState.turnTimer;
        
        if (gameState.turnTimer <= 0) {
          // Auto-draw and switch turn
          if (gameState.currentPlayer === 'player') {
            drawCard();
          }
          switchTurn();
        }
      }, 1000);
    }

    function resetTurnTimer() {
      gameState.turnTimer = 30;
      document.getElementById('turnTimer').textContent = gameState.turnTimer;
    }

    function endGame(winner) {
      gameState.gameActive = false;
      clearInterval(gameState.timerInterval);
      
      if (winner === 'player') {
        showNotification('üéâ You Win!', 'success');
        if (typeof updateCoins === 'function') {
          updateCoins(100, 'uno', 'win');
        }
      } else {
        showNotification('üòî You Lose!', 'error');
      }
    }

    function backToMenu() {
      clearInterval(gameState.timerInterval);
      
      // Leave multiplayer room if in one
      if (gameState.multiplayerRoom) {
        socket.emit('leave-room', { roomId: gameState.multiplayerRoom.id });
      }
      
      // Reset UI
      document.getElementById('modeSelection').style.display = 'grid';
      document.getElementById('gameArea').style.display = 'none';
      document.getElementById('multiplayerInfo').style.display = 'none';
    }

    function updatePlayerList() {
      if (!gameState.multiplayerRoom) return;
      
      const container = document.getElementById('playerList');
      container.innerHTML = gameState.multiplayerRoom.players.map(player => `
        <div class="player-tag ${player.socketId === socket.id ? 'active' : ''}">
          ${player.username}
        </div>
      `).join('');
    }

    function handleMultiplayerAction(data) {
      // Handle multiplayer game actions
      console.log('Multiplayer action:', data);
    }
  </script>
</body>
</html>
